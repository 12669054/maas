/*
 * Copyright 2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.yaml.snakeyaml.Yaml

ext {

    // Target registry to be used to publish docker images needed for deployment
    targetReg = project.hasProperty('targetReg') ? project.getProperty('targetReg') : 'localhost:5000'

    // The tag used to tag the docker images push to the target registry
    targetTag = project.hasProperty('targetTag') ? project.getProperty('targetTag') : 'candidate'

    // Deployment target config file (yaml format); this can be overwritten from the command line
    // using the -PdeployConfig=<file-path> syntax.
    deployConfig = project.hasProperty('deployConfig') ? project.getProperty('deployConfig') : './config/default.yml'

    dockerPath = project.hasProperty('dockerPath') ? project.getProperty('dockerPath') : '/usr/bin'

    vboxUser = project.hasProperty('vboxUser') ? project.getProperty('vboxUser') : 'cord'
}

// Switch Configuration Image

task buildSwitchqImage(type: Exec) {
    commandLine "$dockerPath/docker", 'build', '-t', 'cord-maas-switchq', './switchq'
}

task tagSwitchqImage(type: Exec) {
   dependsOn buildSwitchqImage
   commandLine "$dockerPath/docker", 'tag', 'cord-maas-switchq', "$targetReg/cord-maas-switchq:$targetTag"
}

task publishSwitchqImage(type: Exec) {
    dependsOn tagSwitchqImage
    commandLine "$dockerPath/docker", 'push', "$targetReg/cord-maas-switchq:$targetTag"
}

// Bootstrap Image

task buildBootstrapImage(type: Exec) {
    commandLine "$dockerPath/docker", 'build', '-t', 'cord-maas-bootstrap', './bootstrap'
}

task tagBootstrapImage(type: Exec) {
   dependsOn buildBootstrapImage
   commandLine "$dockerPath/docker", 'tag', 'cord-maas-bootstrap', "$targetReg/cord-maas-bootstrap:$targetTag"
}

task publishBootstrapImage(type: Exec) {
    dependsOn tagBootstrapImage
    commandLine "$dockerPath/docker", 'push', "$targetReg/cord-maas-bootstrap:$targetTag"
}

// IP Allocator Image

task buildAllocationImage(type: Exec) {
    commandLine "$dockerPath/docker", 'build', '-t', 'cord-ip-allocator', './ip-allocator'
}

task tagAllocationImage(type: Exec) {
   dependsOn buildAllocationImage
   commandLine "$dockerPath/docker", 'tag', 'cord-ip-allocator', "$targetReg/cord-ip-allocator:$targetTag"
}

task publishAllocationImage(type: Exec) {
    dependsOn tagAllocationImage
    commandLine "$dockerPath/docker", 'push', "$targetReg/cord-ip-allocator:$targetTag"
}

// Provisioner Image

task buildProvisionerImage(type: Exec) {
    commandLine "$dockerPath/docker", 'build', '-t', 'cord-provisioner', './provisioner'
}

task tagProvisionerImage(type: Exec) {
   dependsOn buildProvisionerImage
   commandLine "$dockerPath/docker", 'tag', 'cord-provisioner', "$targetReg/cord-provisioner:$targetTag"
}

task publishProvisionerImage(type: Exec) {
    dependsOn tagProvisionerImage
    commandLine "$dockerPath/docker", 'push', "$targetReg/cord-provisioner:$targetTag"
}

// Automation Images

task buildAutomationImage(type: Exec) {
    commandLine "$dockerPath/docker", 'build', '-t', "cord-maas-automation", "-f", "./automation/Dockerfile", "./automation"
}

task buildAutomationImageAnsible(type: Exec) {
    commandLine "$dockerPath/docker", 'build', '-t', "cord-maas-automation:ansible", "-f", "./automation/Dockerfile.ansible", "./automation"
}

task buildAutomationImages {
    dependsOn buildAutomationImage
    dependsOn buildAutomationImageAnsible
}

task tagAutomationImage(type: Exec) {
    dependsOn buildAutomationImage
    commandLine "$dockerPath/docker", 'tag', 'cord-maas-automation', "$targetReg/cord-maas-automation:$targetTag"
}

task tagAutomationImageAnsible(type: Exec) {
    dependsOn buildAutomationImageAnsible
    commandLine "$dockerPath/docker", 'tag', 'cord-maas-automation:ansible', "$targetReg/cord-maas-automation:$targetTag-ansible"
}

task tagAutomationImages {
    dependsOn tagAutomationImage
    dependsOn tagAutomationImageAnsible
}

task publishAutomationImage(type: Exec) {
    dependsOn tagAutomationImage
    commandLine "$dockerPath/docker", 'push', "$targetReg/cord-maas-automation:$targetTag"
}

task publishAutomationImageAnsible(type: Exec) {
    dependsOn tagAutomationImageAnsible
    commandLine "$dockerPath/docker", 'push', "$targetReg/cord-maas-automation:$targetTag-ansible"
}

task publishAutomationImages {
    dependsOn publishAutomationImage
    dependsOn publishAutomationImageAnsible
}

// DHCP Harvester Images

task buildHarvesterImage(type: Exec) {
    commandLine "$dockerPath/docker", 'build', '-t', "cord-dhcp-harvester", "./harvester"
}

task tagHarvesterImage(type: Exec) {
    dependsOn buildHarvesterImage
    commandLine "$dockerPath/docker", 'tag', 'cord-dhcp-harvester', "$targetReg/cord-dhcp-harvester:$targetTag"
}

task publishHarvesterImage(type: Exec) {
    dependsOn tagHarvesterImage
    commandLine "$dockerPath/docker", 'push', "$targetReg/cord-dhcp-harvester:$targetTag"
}

// ~~~~~~~~~~~~~~~~~~~ Global tasks ~~~~~~~~~~~~~~~~~~~~~~~

// To be used to fetch upstream binaries, clone repos, etc.
task fetch(type: Exec) {
    // this is where we fetch upstream artifacts that we do not need internet for the build phase"
    // Placeholdr example:
    commandLine "$dockerPath/docker", "pull", "golang:alpine"
    commandLine "$dockerPath/docker", "pull", "python:2.7-alpine"
}

// To be used to generate all needed binaries that need to be present on the target
// as docker images in the local docker runner.
task buildImages {
    dependsOn buildBootstrapImage
    dependsOn buildHarvesterImage
    dependsOn buildAutomationImages
    dependsOn buildAllocationImage
    dependsOn buildProvisionerImage
    dependsOn buildSwitchqImage
}

task tagImages {
    dependsOn tagBootstrapImage
    dependsOn tagHarvesterImage
    dependsOn tagAutomationImages
    dependsOn tagAllocationImage
    dependsOn tagProvisionerImage
    dependsOn tagSwitchqImage
}

task publish {
    dependsOn publishBootstrapImage
    dependsOn publishHarvesterImage
    dependsOn publishAutomationImages
    dependsOn publishAllocationImage
    dependsOn publishProvisionerImage
    dependsOn publishSwitchqImage
}

// ~~~~~~~~~~~~~~~~~~~ Deployment / Test Tasks  ~~~~~~~~~~~~~~~~~~~~~~~

List.metaClass.asParam = { prefix, sep ->
  if (delegate.size() == 0) {
    ""
  }
  String result = "--" + prefix + "="
  String p = ""
  delegate.each {
    result += p + "${it}"
    p = sep
  }
  result
}

List.metaClass.p = { value, name ->
  if (value != null && value != "") {
      delegate << name + "=" + value
  } else {
      delegate
  }
}

List.metaClass.p = { spec ->
  if (spec != null && spec != "") {
      delegate += spec
  } else {
      delegate
  }
}

task prime (type: Exec) {
    println "Using deployment config: $deployConfig"
    File configFile = new File(deployConfig)
    def yaml = new Yaml()
    def config = yaml.load(configFile.newReader())

    executable = "ansible-playbook"
    args = ["-i", config.seedServer.ip + ',']

    if ( config.seedServer.user != null && config.seedServer.user != "" ) {
        args = args << "--user=$config.seedServer.user"
    }

    def extraVars = []
    if (config.seedServer) {
        extraVars = extraVars.p(config.seedServer.extraVars)
            .p(config.seedServer.password, "ansible_ssh_pass")
            .p(config.seedServer.sudoPassword, "ansible_sudo_pass")
            .p(config.seedServer.fabric_ip, "fabric_ip")
            .p(config.seedServer.management_ip, "management_ip")
            .p(config.seedServer.management_network, "management_network")
            .p(config.seedServer.management_iface, "management_iface")
            .p(config.seedServer.external_ip, "external_ip")
            .p(config.seedServer.external_network, "external_network")
            .p(config.seedServer.external_iface, "external_iface")
            .p(config.seedServer.fabric_ip, "fabric_ip")
            .p(config.seedServer.fabric_network, "fabric_network")
            .p(config.seedServer.fabric_iface, "fabric_iface")
            .p(config.seedServer.domain, "domain")
    }

    if (vboxUser != "") {
        extraVars = extraVars.p(vboxUser, "power_helper_user")
    }

    if (config.otherServers) {
        extraVars = extraVars.p(config.otherServers.location, "prov_location")
        .p(config.otherServers.rolesPath, "prov_role_path")
        .p(config.otherServers.role, "prov_role")
    }

    if (config.docker) {
        extraVars = extraVars.p(config.docker.registry, "docker_registry")
            .p(config.docker.imageVersion, "docker_image_version")
    }

    def skipTags = [].p(config.seedServer.skipTags)

    args = args.p(skipTags.asParam("skip-tags", ",")).p(extraVars.asParam("extra-vars", " ")) << "prime-node.yml"
}

task deploy (type: Exec) {
    println "Using deployment config: $deployConfig"
    File configFile = new File(deployConfig)
    def yaml = new Yaml()
    def config = yaml.load(configFile.newReader())

    executable = "ansible-playbook"
    args = ["-i", config.seedServer.ip + ',']

    if ( config.seedServer.user != null && config.seedServer.user != "" ) {
        args = args << "--user=$config.seedServer.user"
    }

    def extraVars = []
    if (config.seedServer) {
        extraVars = extraVars.p(config.seedServer.extraVars)
            .p(config.seedServer.password, "ansible_ssh_pass")
            .p(config.seedServer.sudoPassword, "ansible_sudo_pass")
            .p(config.seedServer.fabric_ip, "fabric_ip")
	    .p(config.seedServer.management_ip, "management_ip")
            .p(config.seedServer.management_network, "management_network")
	    .p(config.seedServer.management_iface, "management_iface")
	    .p(config.seedServer.external_ip, "external_ip")
            .p(config.seedServer.external_network, "external_network")
            .p(config.seedServer.external_iface, "external_iface")
	    .p(config.seedServer.fabric_ip, "fabric_ip")
	    .p(config.seedServer.fabric_network, "fabric_network")
	    .p(config.seedServer.fabric_iface, "fabric_iface")
            .p(config.seedServer.domain, "domain")
	    .p(config.seedServer.power_helper_user, "power_helper_user")
	    .p(config.seedServer.power_helper_host, "power_helper_host")
    }

    if (vboxUser != "") {
        extraVars = extraVars.p(vboxUser, "power_helper_user")
    }

    if (config.otherServers) {
        extraVars = extraVars.p(config.otherServers.location, "prov_location")
        .p(config.otherServers.rolesPath, "prov_role_path")
        .p(config.otherServers.role, "prov_role")
    }

    if (config.docker) {
        extraVars = extraVars.p(config.docker.registry, "docker_registry")
            .p(config.docker.imageVersion, "docker_image_version")
    }

    def skipTags = [].p(config.seedServer.skipTags)

    args = args.p(skipTags.asParam("skip-tags", ",")).p(extraVars.asParam("extra-vars", " ")) << "head-node.yml"
}
